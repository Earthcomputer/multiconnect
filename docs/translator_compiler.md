# Translator Compiler
The majority of the translation in multiconnect is done by code generated by the translator compiler. The translator compiler takes two inputs: the CSV files in the `data` directory, and annotations in the multiconnect source code.

![Compiler Overview](compiler_overview.svg)

## Messages
A message is a unit of data that is sent over the network. Packets are a type of message, as are structs inside a packet.

Messages are defined as classes annotated with the `@Message` annotation. They must have one or more *record fields*, which are public non-static non-final fields inside the message class, and must be constructible via a no-arg constructor (unless it's a [polymorphic parent](#polymorphism)). A message is serialized by serializing each of its record fields in sequence. Messages do not allow recursion in their data structure, except for [tail recursion](#tail-recursion) in limited cases.

### Record Field Types
A record field must have one of the following types:

- Primitive type
- `String`
- A message type
- A [network enum](#network-enums)
- `UUID`
- `Identifier`
- `NbtCompound`
- `OptionalInt`
- `OptionalLong`
- `IntList`
- `LongList`
- `BitSet`
- `Optional`, `List` or array of any valid record field type

### Wire Types
A field additionally has a *wire type*, which specifies how the field is serialized on the wire. Most types have their own wire type, but it's worth noting that ints and longs default to using varint and varlong respectively as their wire types. You can change the wire type of a field with the `@Type` annotation.

Optional types are serialized by default has a boolean, followed by the wire type if the boolean was true. List types are serialized by default using a varint to specify the length, followed by that number of repititions of the wire type.

The way list type lengths are serialized and calculated can be customized using the `@Length` annotation. You can change the wire type of the length, or specify a [multiconnect function](#multiconnect-functions) to compute the length from preceding fields, or specify a constant value for the length.

A field of type `byte[]` may be annotated with `@RemainingBytes` to override the normal length computation and fill the byte array with all remaining bytes in the ByteBuf.

### Conditions using `@OnlyIf`
You can specify a [multiconnect function](#multiconnect-functions) which returns a boolean for whether a field annotated with `@OnlyIf` is present or should be skipped.

### Polymorphism
Polymorphism is the primary way to introduce a choice of how to deserialize subsequent data. All polymorphic types are annotated with `@Polymorphic`. They consist of a *polymorphic base*, which is an abstract `@Message` class, and *polymorphic subclasses* which extend the polymorphic base. Only one layer of inheritance is allowed - no grandchild classes are allowed.

The polymorphic subclass to deserialize to is determined by the *polymorphic type field*, which is the first record field in the polymorphic base. Each polymorphic subclass specifies a condition on this field for whether that subclass should be used. This can be specified in the form of one or more [constants](#constants), or as [multiconnect function](#multiconnect-functions) conditions, or using a catch-all `otherwise = true` clause.

Sometimes, the polymorphic type field may be specified earlier in the packet, rather than directly prior to the polymorphic message. In this case, you may use the `@PolymorphicBy` annotation on the record field referencing the polymorphic type, and specify the record field from which to take the value of the polymorphic type field.

### Tail Recursion
Normally messages are not allowed to be recursive, except for tail recursion. Tail recursion is allowed in two cases:

- In a non-polymorphic message type with `tailrec = true` in the `@Message` annotation, the last field of the message may have the type of the message itself. The last field must be annotated with [`@OnlyIf`](#conditions-using-onlyif) in this case.
- In a polymorphic subclass where the polymorphic base has `tailrec = true` in the `@Message` annotation, the last field of the subclass may have the type of the polymorphic base. There must be at least one polymorphic subclass of the polymorphic base which either does not have a tail recursive field or has a tail recursive field annotated with [`@OnlyIf`](#conditions-using-onlyif).

### Multiconnect Functions
Multiconnect functions are public static methods in the same class from which they are referenced. These functions must be unique by name within the class, i.e. multiconnect functions do not support overloading. The translator compiler will generate calls to these functions, typically on the network thread, so be mindful of potential threading issues inside these functions.

Multiconnect functions have an *context message*, which unless otherwise specified by the documentation for the place the function is referenced, is the message the function is referenced from.

The return type of multiconnect functions can vary, and requirements depend on where the function is used. Multiconnect functions may have the following types of parameters:

- Positional parameters: parameters without a multiconnect annotation, before any other parameters. Unless otherwise specified by the documentation for the place the function is referenced, multiconnect functions do not allow any positional parameters.
- Context parameters: parameters annotated with `@Argument`. Passes the value of a field from the context message. The annotation specifies the name of the record field to pull from.
- Default constructed parameters: parameters annotated with `@DefaultConstruct`. The translator compiler will generate code to construct an instance of the type of the parameter as per [default construction](#default-construction), and pass the instance in. If the parameter type is a `Supplier`, then the generated code will instead pass a `Supplier` which creates a new default-constructed instance of the supplied type on each invocation of `get()`.
- Filled parameters: parameters annotated with `@Filled`. A value is passed into this parameter by the generated code depending on its type. Supported types are:
  - `ClientPlayNetworkHandler` - passes the current network handler.
  - `IUserDataHolder` - passes a user data holder that's valid from when the packet was sent/received until it is handled. This holder remains valid for the packets returned from a packet's handler, if any.
  - `Identifier` and integral types - if the `@Filled` annotation has a `fromRegistry` attribute, then the parameter is filled with the string or numeric identifier for the registry entry specified.

### Network Enums
Network enums are simply enums annotated with the `@NetworkEnum` annotation. They must have at least one value. Record fields with a network enum type are serialized as if they were ints.

### Constants
Whenever a constant value is required in an annotation, the annotation has the following attributes:

- `booleanValue`
- `intValue`
- `doubleValue`
- `stringValue`

All of these are arrays defaulting to empty, except `booleanValue` which defaults to false. `intValue` actually takes a long array. If one constant is expected, the arrays must have a maximum length of 1.

Depending on the expected type of the constant, one of these annotation attributes is expected to be used:

| Type | Constant |
|---|---|
| `boolean` | `booleanValue` |
| Integral field annotated with `@Registry` | `stringValue`, converted as if by `registry.getRawId(registry.get(new Identifier(value)))` |
| Integral | `intValue` |
| `float`, `double` | `doubleValue` |
| `String` | `stringValue` |
| `Identifier` | `stringValue`, converted as if by `new Identifier(value)` |
| Network enum `T` | `stringValue`, converted as if by `T.valueOf(value)` |

No other types are supported for constant values.

### Default Construction
Translator types have default ways of being default constructed:
![Default Construction Diagram](default_construction.svg)
\* - see [constants](#constants).  
\*\* - see [tail recursion](#tail-recursion).

### Message Translation

## Packets
Packets undergo normal [message translation](#message-translation), in addition to a few extra things. This section details those extra things.

Packets are not allowed to be polymorphic.

The list of packets for each version is defined in `data/<version>/cpackets.csv` for serverbound packets and `data/<version>/spackets.csv` for clientbound packets. These files define the packet ID in that version, followed by the [message class](#messages) for the packet on that version. 
- For every supported server version, a clientbound translator is generated for every spacket that servers of that version might send (every packet in that version's spackets file), and for spackets in later versions marked as [sendable](#sendable). 
- For every supported server version, a serverbound translator is generated for every cpacket that clients of the latest version might send (every packet in the latest version's cpackets file), and for cpackets in versions greater than or equal to the server version that are marked as [sendable](#sendable).

### Packet Handlers
Every packet must have some way of being handled. There are two ways that a packet can be handled.

- Fallthrough - the packet is translated into the target version and serialized into the ByteBuf (if it was even deserialized in the first place). This type of handling is implicit and requires no explicit markers.
- Explicit handlers - a [multiconnect function](#multiconnect-functions) annotated with `@Handler` in any packet class along the chain will be called instead of the packet being translated past the version the handler is declared in. The handler may return `void` for no further processing, or it may return a packet type from the next version in the chain and continue translating from there, or finally it may return a list of such packets, which will be translated and handled in order.

### Partial Packet Handlers
In addition to handlers, packets may also have partial handlers which don't stop further translation of the packet. Partial handlers are [multiconnect functions](#multiconnect-functions) annotated with `@PartialHandler` in the packet classes. They are called as the packet is translated past the version they are defined for.

### `@Sendable`
